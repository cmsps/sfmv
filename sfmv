#!/bin/sh
#
# sfcp file | dir newName  - safe cp (copy)
# sfmv file | dir newName  - safe mv (rename)
#
# sfcp item ... dir - safe cp files and / or dirs to dir
# sfmv item ... dir - safe mv files and / or dirs to dir
#
# Sun Jun 18 13:22:20 BST 2017
#


<<'______________D__O__C__U__M__E__N__T__A__T__I__O__N_____________'

Copyright (C) 2017 Peter Scott - p.scott@shu.ac.uk

Licence
-------
   This program is free software: you can redistribute it and / or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

Description
-----------
  `sfmv' is a safe version of the `mv' command; it does not overwrite
  existing files or directories.  It issues error messages when problems
  occur.  If it is run under a name ending with "cp" it is a safe version
  of the `cp' command.

  Also, `sfmv' warns what the effect of the command was when there are
  only two arguments and the second is not a directory.

Rationale
---------
  You can use the -n or --no-clobber option of `mv' or `cp' to avoid
  overwriting existing files.  However, those commands do not notify
  you that they have failed to move or copy something.  `sfmv' issues
  an error message in such a case.

  Also, `mv' is overloaded in that it does renames as well as moves.
  For clarity, `sfmv' issues a explanation when it does more than move
  or copy a file to a directory given as the last argument.


______________D__O__C__U__M__E__N__T__A__T__I__O__N_____________


# usage - display usage message
#
usage(){
  cat <<-! >&2
	Usage: $NAME [ -qh ] file | dir newName
	   or: $NAME [ -qh ] item ... dir

	Options:
	  -h  this help
	  -q  quiet -- no explanations
	!
  exit 1
}


# checkSimple file - check for simple file (Bourne shell)
#
#    return codes: 0=OK; 1=nosuch; 2=directory; 3=unreadable; 4=empty
#
checkSimple(){
  file=$1
  ls "$file" > /dev/null 2>&1
  if [ $? -ne 0 ] ;then
       echo "$NAME: $file: does not exist"
       return 1
  elif [ -d "$file" ] ;then
       echo "$NAME: $file: is a directory"
       return 2
  elif [ ! -r "$file" ] ;then
       echo "$NAME: $file: is not readable"
       return 3
  elif [ ! -s "$file" ] ;then
       echo "$NAME: $file: is empty"
       return 4
  else
       return 0
  fi >&2
}


# prevent the user giving the script a name containing white space
# -- saving the hassle of quoting internal file names
#
NAME=`basename "$0"`
words=`echo "$NAME" | wc -w`
if [ $words -ne 1 ] ;then
     echo "\`$NAME': I don't allow white space in command names" >&2
     exit 2
fi

# moving or copying?
#
case $NAME in
  *cp)
     command='cp -r'   # items may be dirs
     action=copied
     ;;
  *mv)
     command=mv
     action=moved
     ;;
  *)
     echo "\`$NAME': must end with \`cp' or \`mv'" >&2
     exit 3
esac

# process command line options
#
while getopts ':hq' option ;do
     case $option in
       h) usage ;;
       q) quiet=yes ;;
      \?) echo "$NAME: unknown option: \`$OPTARG'" >&2
          usage
     esac
done
shift `expr $OPTIND - 1`

# get last arg -- destination
#
test "$2" || usage
for arg ;do
     dest="$arg"
done

# deal with destination that is not an existing dir (and finish)
#
checkSimple "$dest" 2> /dev/null
case $? in       # 0=ok; 1=nosuch; 3=unreadable; 4=empty
  0 | 3 | 4)
     echo "$NAME: $dest: existing file" >&2
     exit 4
     ;;

  1) # dest doesn't exist -- could be a rename or copy if only two args
     #
     if [ $# -ne 2 ] ;then
          echo "$NAME: $dest: not an existing directory" >&2
          exit 5
     fi

     # check item exists and readable
     #
     item=$1
     checkSimple "$item" 2> /dev/null
     case $? in      # 1=nosuch; 3=unreadable
       1 | 3)
          checkSimple "$item"
          exit `expr $? + 10`
     esac

     # check dir of destination exists (it may only be `.')
     #
     destDir=`dirname "$dest"`
     if [ ! -d "$destDir" ] ;then
          echo "$NAME: $destDir: not an existing directory" >&2
          exit 6
     fi

     # work out type of copy / rename / move
     #
     sourceDir=`dirname "$item"`
     if [ "$sourceDir" != "$destDir" ] ;then
          preposition=to
     else
          preposition=in
          test $action = moved && action=renamed
     fi
     if [ "$destDir" = . ] ;then
          directory='the current'
     else
          directory=another
     fi

     # do simple command
     #
     $command "$item" "$dest" || exit $?

     # display explanation
     #
     if [ "$quiet" != yes ] ;then
          echo "$NAME: $action one item $preposition $directory directory" >&2
     fi
     exit 0
esac

# process all arguments but last one
#
count=0
for arg ;do
     count=`expr $count + 1`
     test $count -eq $# && exit 0
     checkSimple "$arg" 2> /dev/null
     case $? in      # 1=nosuch; 3=unreadable
       1 | 3)
          checkSimple "$arg"
          ;;
       *)
          item=`basename "$arg"`
          checkSimple "$dest/$item" 2> /dev/null
          case $? in    # 1=nosuch
            1) $command "$arg" "$dest" ;;
            *) echo "$NAME: $dest/$item: already exists" >&2
          esac
     esac
done
