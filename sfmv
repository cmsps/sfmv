#!/bin/sh
#
# sfcp file | dir newName  - safe cp
# sfmv file | dir newName  - safe rename (or move)
#
# sfcp item ... dir - safe cp files and / or dirs to dir
# sfmv item ... dir - safe mv files and / or dirs to dir
#
# Tue Sep 8 22:06:27 BST 2015
#


<<'______________D__O__C__U__M__E__N__T__A__T__I__O__N_____________'

Copyright (C) 2016 Peter Scott - p.scott@shu.ac.uk

Licence
-------
   This program is free software: you can redistribute it and / or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.


Description
-----------

  `sfmv' is a safe version of the `mv' command; it does not overwrite
  existing files or directories.  It issues error messages when problems
  occur.  If it is run under a name ending with "cp" it is a safe version
  of the `cp' command.

Rationale
---------

  You can use the -n or --no-clobber option of `mv' or `cp' to avoid
  overwriting existing files.  However, those commands do not notify
  you that they have failed to move or copy something.  `sfmv' issues
  an error message in such a case.


______________D__O__C__U__M__E__N__T__A__T__I__O__N_____________


# usage - display usage message
#
usage(){
  cat <<-! >&2
	Usage: $NAME [ -wh ] file | dir newName
	   or: $NAME [ -wh ] item ... dir

	Options:
	  -h  this help
	  -w  no warning
	!
  exit 1
}


# checkSimple file - check file is plain, readable, not empty (Bourne)
#
checkSimple(){
  file=$1
  ls "$file" > /dev/null 2>&1
  if [ $? -ne 0 ]
  then echo "$NAME: $file: does not exist"
       return 1
  elif [ -d "$file" ]
  then echo "$NAME: $file: is a directory"
       return 2
  elif [ ! -r "$file" ]
  then echo "$NAME: $file: is not readable"
       return 3
  elif [ ! -s "$file" ]
  then echo "$NAME: $file: is empty"
       return 4
  else
       return 0
  fi >&2
}


# prevent the user giving the script a name with white space in it
# -- saving the hassle of quoting internal file names
#
NAME=`basename "$0"`
words=`echo "$NAME" | wc -w`
if [ $words -ne 1 ]
then echo "\`$NAME': I don't allow white space in command names" >&2
     exit 2
fi

# moving or copying?
#
case $NAME in
  *cp)
     command='cp -r'   # items may be dirs
     action=copied
     ;;
  *mv)
     command=mv
     action=moved
     ;;
  *)
     echo "\`$NAME': must end with \`cp' or \`mv'" >&2
     exit 3
esac

# process command line options
#
while getopts ':hw' option
do   case $option in
       h) usage ;;
       w) warning=no ;;
      \?) echo "$NAME: unknown option: \`$OPTARG'" >&2
          usage
     esac
done
shift `expr $OPTIND - 1`

# get last arg -- destination
#
test "$2" || usage
for arg
do   dest="$arg"
done

# do nothing here if destination is an existing dir
#
checkSimple "$dest" 2> /dev/null
case $? in
  0 | 3 | 4)
     echo "$NAME: $dest: existing file" >&2
     exit 4
     ;;

  1) # dest doesn't exist -- could be a rename or copy if only two args
     #
     if [ $# -ne 2 ]
     then echo "$NAME: $dest: not an existing directory" >&2
          exit 5
     fi

     # check item exists and readable
     #
     item=$1
     checkSimple "$item" 2> /dev/null
     case $? in
       1 | 3)
          checkSimple "$item"
          exit `expr $? + 10`
     esac

     # check destination dir exists
     #
     dir=`dirname "$dest"`
     if [ ! -d "$dir" ]
     then echo "$NAME: $dir: not an existing directory" >&2
          exit 6
     fi

     # do simple command and finish
     #
     $command "$item" "$dest"
     exit 0
esac

# process all args but last one -- destination
#
count=0
for arg
do   count=`expr $count + 1`
     if [ $count -ne $# ]
     then checkSimple "$arg" 2> /dev/null
          case $? in
            1 | 3)
               checkSimple "$arg"
               ;;
            *)
               item=`basename "$arg"`
               checkSimple "$dest/$item" 2> /dev/null
               case $? in
                 1) $command "$arg" "$dest" && actioned=true ;;
                 *) echo "$NAME: $dest/$item: already exists" >&2 ;;
               esac
          esac
     fi
done

# issue warning if needed
#
if [ $# -eq 2 ] && [ "$warning" != no ] && [ "$actioned" ]
then echo "$NAME: warning: $action one item to existing directory" >&2
fi
